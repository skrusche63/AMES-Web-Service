package de.kp.ames.web.core.malware;
/**
 * This Java module is part of the
 *  Application Developer Framework
 *
 *  Project: AMES-Web-Service
 *  Package: de.kp.ames.web.core.malware
 *  Module: ClamAVClient
 *  @author krusche@dr-kruscheundpartner.de
 *
 * Add your semantic annotations within the SemanticAssist tags and
 * mark them with a leading hashtag #:
 *
 * <SemanticAssist>
 *     #av #clam #client #core #malware #web
 * </SemanticAssist>
 *
 */

/**
 *	Copyright 2012 Dr. Krusche & Partner PartG
 *
 *	AMES-Web-Service is free software: you can redistribute it and/or 
 *	modify it under the terms of the GNU General Public License 
 *	as published by the Free Software Foundation, either version 3 of 
 *	the License, or (at your option) any later version.
 *
 *	AMES- Web-Service is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
 * 
 *  See the GNU General Public License for more details. 
 *
 *	You should have received a copy of the GNU General Public License
 *	along with this software. If not, see <http://www.gnu.org/licenses/>.
 *
 */

import java.io.ByteArrayInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketException;

public class ClamAVClient {

	private String host;
    
	private int port;
    private int timeout;
    
	// this is a wrapper to clamav from
	// http://code.google.com/p/clamavj/
	
    //  It is mandatory to prefix commands with n or z, and all commands 
    // inside IDSESSION must be prefixed.
    //
    //  Start/end  a  clamd  session. Within a session multiple SCAN, INSTREAM, 
    // FILDES, VERSION, STATS commands can be sent on the same socket without 
    // opening new connections.  
    
    // Replies from clamd will be in the form '<id>: <response>' where <id> is the 
    // request number (in ascii, starting from 1) and <response> is the usual clamd 
    // reply. The reply lines have same delimiter as the corresponding command had.  
    
    // Clamd will process the commands asynchronously, and reply as soon as it has 
    // finished processing.

    // Clamd requires clients to read all the replies it sent, before sending more 
    // commands to pre-vent prevent vent send() deadlocks. The recommended way to 
    // implement a client that uses IDSESSION is with non-blocking sockets, and  
    // a select()/poll() loop:  whenever send would block, sleep in select/poll  
    // until either you can write more data, or read more replies.  
    
    // Note that using non-blocking nonblocking blocking sockets without the select/poll 
    // loop and alternating recv()/send() doesn't comply with clamd's requirements.
    
    // If clamd detects that a client has deadlocked, it will close the connection. 
    // Note that clamd may close an IDSESSION connection too if you don't follow 
    // the protocol's requirements.
   
    private static final int CHUNK_SIZE = 2048;

    private static final byte[] INSTREAM = "zINSTREAM\0".getBytes();
    private static final byte[] PING 	 = "zPING\0".getBytes();
    private static final byte[] STATS 	 = "nSTATS\n".getBytes();

	/**
	 * Constructor
	 */
	public ClamAVClient() {		
	}

	/**
	 * Constructor
	 * 
	 * @param host
	 * @param port
	 * @param timeout
	 */
	public ClamAVClient(String host, int port, int timeout)	{

		this.host = host;
        this.port = port;
        
        /* 
         * Socket timeout in milliseconds
         */
        this.timeout = timeout;
 
	}
	
    /**
     * @return
     */
    public boolean ping() {
        return "PONG\0".equals(command(PING));
    }

    /**
     * @return
     */
    public String stats() {
        return command(STATS);
    }

    /**
     * @param cmd
     * @return
     */
    private String command(byte[] cmd){

        Socket socket = new Socket();

        DataOutputStream dos = null;
        String response = null;

        try {

        	/* 
        	 * Connect to socket
        	 */
        	socket.connect(new InetSocketAddress(host, port));
 
        	/* 
        	 * Set timeout
        	 */
            socket.setSoTimeout(timeout);

            dos = new DataOutputStream(socket.getOutputStream());

            dos.write(cmd);
            dos.flush();

            InputStream stream = socket.getInputStream();

            int read = CHUNK_SIZE;
            byte[] buffer = new byte[CHUNK_SIZE];
            
            StringBuffer sb = new StringBuffer();
            
            while (read ==CHUNK_SIZE){
            	
                read = stream.read(buffer);
                sb.append(new String(buffer, 0, read));
            
            }

            response = sb.toString();

        } catch (SocketException e) {
            e.printStackTrace();

        } catch (IOException e) {
            e.printStackTrace();
            return null;    
 
        } finally {
 
        	if (dos != null) {
            	
            	try { 
            		dos.close(); 
            		
            	} catch (IOException e) { 
            		e.printStackTrace();
            	}
            }

            try { 
            	socket.close(); 
            
            } catch (IOException e) {
            	e.printStackTrace();
            	
            }
        }

        return response;
	}



	/**
     * This method streams the contents of the InputStream to clamd, 
     * so the entire content is not loaded into memory at the same time.
	 * 
	 * @param stream
	 * @return
	 */
	public ScanResult scan(InputStream stream) {

        Socket socket = new Socket();

        DataOutputStream dos = null;
        String response = null;
        
        try {
 
        	// connect to socket
        	socket.connect(new InetSocketAddress(host, port));
 
        	// set timeout
            socket.setSoTimeout(timeout);

            // write inputstream to socket
            dos = new DataOutputStream(socket.getOutputStream());
            dos.write(INSTREAM);
 
            int read = CHUNK_SIZE;
            byte[] buffer = new byte[CHUNK_SIZE];
            while (read == CHUNK_SIZE){
 
            	read = stream.read(buffer);
 
                dos.writeInt(read);
                dos.write(buffer, 0, read);
 
            }
            
            dos.writeInt(0);
            dos.flush();           

            try {
                read = socket.getInputStream().read(buffer);
            
            } catch (IOException e){
            	e.printStackTrace();
            	read = 0;
            }

            if (read > 0) response = new String(buffer, 0, read);
               
        } catch (SocketException e1) {
        	return new ScanResult(e1);
        
        } catch (IOException e2) {
            return new ScanResult(e2);    

        } finally {
            
        	if (dos != null) {
        		try { dos.close(); 
        		
        		} catch (IOException e) { 
        			e.printStackTrace();
        			
        		}
        	
        	}
            
        	try { 
        		socket.close(); 
        	
        	} catch (IOException e) { 
        		e.printStackTrace();
        		
        	}
        }

        return new ScanResult(response.trim());
		
	}


	/**
     * The method to call if you already have the content
	 * to scan in-memory as a byte array.
	 * 
	 * @param bytes
	 * @return
	 */
	public ScanResult scan(byte[] bytes) {
       return scan(new ByteArrayInputStream(bytes));
   }
	
    /**
     * @return
     */
    public String getHost() {
        return host;
    }

    /**
     * @param host
     */
    public void setHost(String host) {
        this.host = host;
    }

    /**
     * @return
     */
    public int getPort() {
        return port;
    }

    /**
     * @param port
     */
    public void setPort(int port) {
        this.port = port;
    }

    /**
     * @return
     */
    public int getTimeout() {
        return timeout;
    }

 
    /**
     * Socket timeout in milliseconds
	 *
     * @param timeout
     */
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }
    
}
